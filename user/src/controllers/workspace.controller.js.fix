import axios from 'axios';
import * as cheerio from 'cheerio';
import Workspace from '../models/workspace.model.js';
import Team from '../models/team.model.js';
import { redisClient } from '../utils/redis.js';

// Create a new workspace by scraping a website
const createWorkspace = async (req, res) => {
  try {
    const { name, url, teamId } = req.body;
    const userId = req.userId;

    // Validate input
    if (!name || !url || !teamId) {
      return res.status(400).json({ message: 'Name, URL, and team ID are required' });
    }

    // Check if team exists and user is a member
    const team = await Team.findOne({
      _id: teamId,
      $or: [
        { owner: userId },
        { 'members.user': userId, 'members.status': 'active' }
      ]
    });

    if (!team) {
      return res.status(404).json({ message: 'Team not found or access denied' });
    }

    // Scrape website content with hierarchical tree structure
    const scrapeResult = await scrapeWebsite(url);

    if (!scrapeResult.contents || scrapeResult.contents.length === 0) {
      return res.status(400).json({ message: 'Failed to scrape content from the provided URL' });
    }

    // Create new workspace
    const workspace = new Workspace({
      name,
      sourceUrl: url,
      team: teamId,
      contents: scrapeResult.contents,
      navigationTree: scrapeResult.navigationTree,
      createdBy: userId
    });

    await workspace.save();

    // Add workspace to team
    await Team.findByIdAndUpdate(teamId, { $push: { workspaces: workspace._id } });

    res.status(201).json({
      message: 'Workspace created successfully',
      workspace
    });
  } catch (error) {
    console.error('Create workspace error:', error);
    res.status(500).json({ message: 'Server error during workspace creation' });
  }
};

// Get all workspaces for a team
const getTeamWorkspaces = async (req, res) => {
  try {
    const { teamId } = req.params;
    const userId = req.userId;

    // Check if team exists and user is a member
    const team = await Team.findOne({
      _id: teamId,
      $or: [
        { owner: userId },
        { 'members.user': userId, 'members.status': 'active' }
      ]
    });

    if (!team) {
      return res.status(404).json({ message: 'Team not found or access denied' });
    }

    // Get workspaces
    const workspaces = await Workspace.find({ team: teamId });

    res.status(200).json({ workspaces });
  } catch (error) {
    console.error('Get team workspaces error:', error);
    res.status(500).json({ message: 'Server error while fetching workspaces' });
  }
};

// Get workspace by ID
const getWorkspaceById = async (req, res) => {
  try {
    const { workspaceId } = req.params;
    const userId = req.userId;

    // Find workspace and check access
    const workspace = await Workspace.findById(workspaceId).populate('team');
    
    if (!workspace) {
      return res.status(404).json({ message: 'Workspace not found' });
    }

    // Check if user is a member of the team
    const team = await Team.findOne({
      _id: workspace.team,
      $or: [
        { owner: userId },
        { 'members.user': userId, 'members.status': 'active' }
      ]
    });

    if (!team) {
      return res.status(403).json({ message: 'Access denied' });
    }

    res.status(200).json({ workspace });
  } catch (error) {
    console.error('Get workspace error:', error);
    res.status(500).json({ message: 'Server error while fetching workspace' });
  }
};

// Update content in workspace
const updateContent = async (req, res) => {
  try {
    const { workspaceId, contentId } = req.params;
    const { content } = req.body;
    const userId = req.userId;

    // Find workspace
    const workspace = await Workspace.findById(workspaceId);
    
    if (!workspace) {
      return res.status(404).json({ message: 'Workspace not found' });
    }

    // Check if user has access to workspace
    const team = await Team.findOne({
      _id: workspace.team,
      $or: [
        { owner: userId },
        { 'members.user': userId, 'members.status': 'active' }
      ]
    });

    if (!team) {
      return res.status(403).json({ message: 'Access denied' });
    }

    // Find and update content
    const contentItem = workspace.contents.id(contentId);
    
    if (!contentItem) {
      return res.status(404).json({ message: 'Content not found' });
    }

    contentItem.content = content;
    contentItem.lastEditedBy = userId;
    contentItem.lastEditedAt = Date.now();

    await workspace.save();

    res.status(200).json({
      message: 'Content updated successfully',
      content: contentItem
    });

    if (req.body.isPublic) {
      await updatePublicLink(workspaceId);
    } else {
      await redisClient.del(`publicLink:${workspaceId}`);
    }
  } catch (err) {
    console.error(err);
    return res.status(400).send({ message: "Error updating workspace" });
  }
};

async function updatePublicLink(workspaceId) {
  // Implementation for updatePublicLink
  console.log("updatePublicLink function called for workspaceId:", workspaceId);
}

// Add new content to workspace
const addContent = async (req, res) => {
  try {
    const { workspaceId } = req.params;
    const { title, content, path, parentPath } = req.body;
    const userId = req.userId;

    // Validate input
    if (!title || !content || !path) {
      return res.status(400).json({ message: 'Title, content, and path are required' });
    }

    // Find workspace
    const workspace = await Workspace.findById(workspaceId);
    
    if (!workspace) {
      return res.status(404).json({ message: 'Workspace not found' });
    }

    // Check if user has access to workspace
    const team = await Team.findOne({
      _id: workspace.team,
      $or: [
        { owner: userId },
        { 'members.user': userId, 'members.status': 'active' }
      ]
    });

    if (!team) {
      return res.status(403).json({ message: 'Access denied' });
    }

    // Add new content
    workspace.contents.push({
      title,
      content,
      path,
      parentPath: parentPath || '',
      lastEditedBy: userId,
      lastEditedAt: Date.now()
    });

    await workspace.save();

    res.status(201).json({
      message: 'Content added successfully',
      content: workspace.contents[workspace.contents.length - 1]
    });
  } catch (error) {
    console.error('Add content error:', error);
    res.status(500).json({ message: 'Server error while adding content' });
  }
};

// Helper function to scrape website content with hierarchical tree structure for any documentation site
const scrapeWebsite = async (url, maxDepth = 2, currentDepth = 0, visitedUrls = new Set()) => {
  try {
    // Normalize URL
    const baseUrl = new URL(url).origin;
    const normalizedUrl = url.endsWith('/') ? url.slice(0, -1) : url;
    
    // Skip if already visited or max depth reached
    if (visitedUrls.has(normalizedUrl) || currentDepth > maxDepth) {
      return { contents: [], navigationTree: [] };
    }
    
    console.log(`Scraping ${normalizedUrl} (depth: ${currentDepth}/${maxDepth})`);
    visitedUrls.add(normalizedUrl);
    
    const response = await axios.get(normalizedUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
      }
    });
    
    const $ = cheerio.load(response.data);
    const contents = [];
    const navigationTree = [];
    
    // Extract title and pathnot i
    const pageTitle = $('title').text().trim();
    const urlPath = new URL(normalizedUrl).pathname;
    const pagePath = urlPath === '/' ? 'index' : urlPath.replace(/^\//g, '').replace(/\//g, '-');
    
    // Process main content
    const mainContent = {
      id: pagePath,
      title: pageTitle || 'Main Page',
      content: { 
        type: 'doc', 
        content: [{ 
          type: 'paragraph', 
          content: [{ 
            type: 'text', 
            text: $('main, article, .content, .documentation, #content').text().trim() || $('body').text().trim() 
          }] 
        }] 
      },
      url: normalizedUrl,
      children: []
    };
    
    contents.push(mainContent);
    
    // Extract navigation structure - Look for sidebar/navigation elements
    // Find the navigation element (sidebar)
    let navElement = null;
    let bestNavElement = null;
    let maxNavScore = 0;
    
    // Universal navigation detection for any documentation site
    // First try common documentation site selectors
    if (url.includes('langfuse.com') || url.includes('docs.langfuse')) {
      console.log('Using specialized Langfuse navigation detection');
      
      // Langfuse-specific selectors based on the screenshots
      const langfuseSelectors = [
        // Try very specific selectors first
        'nav[aria-label="Sidebar"]',
        '.sidebar-container',
        '.sidebar-content',
        '.sidebar-items',
        '.sidebar-navigation',
        // Then try more general selectors
        'nav',
        '.sidebar',
        '[role="navigation"]'
      ];
      
      // Try to find the navigation element using Langfuse-specific selectors
      for (const selector of langfuseSelectors) {
        try {
          const element = $(selector);
          if (element.length > 0) {
            navElement = element;
            console.log(`Found Langfuse navigation with selector: ${selector}`);
            break;
          }
        } catch (e) {
          continue;
        }
      }
      
      // If still not found, look for elements with specific Langfuse navigation patterns
      if (!navElement) {
        // Look for elements that contain the typical Langfuse navigation items
        $('div, nav, aside').each((_, element) => {
          if (navElement) return; // Skip if already found
          
          const $element = $(element);
          const text = $element.text();
          
          // Check if this element contains typical Langfuse navigation text
          const hasLangfuseItems = [
            'Tracing', 'Introduction', 'Data Model', 'Quickstart',
            'Docs', 'Self Hosting', 'Guides', 'FAQ',
            'LLM Application Observability', 'Prompt Management'
          ].some(item => text.includes(item));
          
          if (hasLangfuseItems && $element.find('a').length > 5) {
            navElement = $element;
            console.log('Found Langfuse navigation by content analysis');
          }
        });
      }
    } else {
      // For non-Langfuse sites, use the general approach
      console.log('Using general navigation detection');
      
      const navSelectors = [
        // Common documentation sidebar selectors
        'nav[aria-label="Sidebar"]', '.sidebar-container', '.sidebar-content', '.sidebar-items', '.sidebar-navigation',
        '.sidebar', '.sidebar-nav', '.docs-sidebar', '.navigation', '.docs-navigation', '.doc-navigation',
        'nav', '#sidebar', '#navigation', '.nav-menu', '.menu', '.toc', '.table-of-contents',
        // Documentation frameworks selectors
        '.docusaurus-sidebar', '.nextra-sidebar', '.vuepress-sidebar', '.nuxt-content-sidebar',
        '.gatsby-sidebar', '.mkdocs-sidebar', '.jekyll-sidebar', '.gitbook-sidebar',
        // Attribute-based selectors
        '[role="navigation"]', '[aria-label*="nav"]', '[aria-label*="menu"]', '[aria-label*="sidebar"]',
        // Class-based common patterns
        '[class*="sidebar"]', '[class*="navigation"]', '[class*="menu"]', '[class*="toc"]', '[class*="nav"]',
        // ID-based common patterns
        '[id*="sidebar"]', '[id*="navigation"]', '[id*="menu"]', '[id*="toc"]', '[id*="nav"]'
      ];
      
      // Find the navigation element using various common selectors
      for (const selector of navSelectors) {
        try {
          const elements = $(selector);
          if (elements.length > 0) {
            // For each matching element, calculate a "navigation score"
            let bestScore = 0;
            let bestElement = null;
            
            elements.each((_, element) => {
              const $element = $(element);
              
              // Skip very large elements (likely the main content)
              if ($element.find('*').length > 1000) return;
              
              // Calculate navigation score based on navigation-like elements
              const linkCount = $element.find('a').length;
              const listItemCount = $element.find('li').length;
              const headingCount = $element.find('h1, h2, h3, h4, h5, h6').length;
              const nestedListCount = $element.find('ul ul, ol ol, ul ol, ol ul').length;
              
              // Elements that suggest this is a navigation component
              const hasExpandCollapseIcons = $element.find('svg, img[alt*="expand"], img[alt*="collapse"]').length > 0;
              const hasNestedStructure = nestedListCount > 0;
              
              // Calculate score - higher is more likely to be navigation
              let score = linkCount * 2 + listItemCount + headingCount + (nestedListCount * 3);
              if (hasExpandCollapseIcons) score += 10;
              if (hasNestedStructure) score += 5;
              
              // Penalize if this element contains large text blocks (likely content, not navigation)
              const textBlocks = $element.find('p').length;
              score -= textBlocks * 2;
              
              // If this is the best candidate so far, save it
              if (score > bestScore && linkCount > 5) {
                bestScore = score;
                bestElement = $element;
              }
            });
            
            if (bestElement) {
              navElement = bestElement;
              console.log(`Found navigation element with selector: ${selector} and score: ${bestScore}`);
              break;
            }
          }
        } catch (e) {
          // Some selectors might cause errors, just skip them
          continue;
        }
      }
      
      // If we still don't have a nav element, try to find it by looking for elements with many links
      if (!navElement) {
        $('nav, aside, div, ul').each((_, element) => {
          // Skip if we already found a navigation element
          if (navElement) return;
          
          const $element = $(element);
          
          // Skip very small or very large elements
          const elementSize = $element.find('*').length;
          if (elementSize < 5 || elementSize > 1000) return;
          
          // Count navigation-like features
          const linkCount = $element.find('a').length;
          const listItemCount = $element.find('li').length;
          
          // Skip elements with too few links
          if (linkCount < 5) return;
          
          // Check if links are grouped together (navigation pattern)
          const linkDensity = linkCount / elementSize;
          if (linkDensity > 0.3) {
            navElement = $element;
            console.log(`Found navigation element by link density: ${linkDensity}`);
          }
        });
      }
    }
    
    // Use the best candidate if found
    if (bestNavElement) {
      navElement = bestNavElement;
    }
    
    // Second pass: if no good candidate found, look for elements with navigation-like structure
    if (!navElement || maxNavScore < 10) {
      $('nav, aside, div, ul').each((_, element) => {
        // Skip if we already found a good navigation element
        if (navElement && maxNavScore >= 20) return;
        
        const $element = $(element);
        
        // Skip very small or very large elements
        const elementSize = $element.find('*').length;
        if (elementSize < 5 || elementSize > 1000) return;
        
        // Count navigation-like features
        const linkCount = $element.find('a').length;
        const listItemCount = $element.find('li').length;
        const headingCount = $element.find('h1, h2, h3, h4, h5, h6').length;
        const nestedListCount = $element.find('ul ul, ol ol, ul ol, ol ul').length;
        
        // Skip elements with too few links
        if (linkCount < 5) return;
        
        // Calculate score
        let score = linkCount * 2 + listItemCount + headingCount + (nestedListCount * 3);
        
        // Check if links are grouped together (navigation pattern)
        const linkDensity = linkCount / elementSize;
        if (linkDensity > 0.3) score += 10;
        
        // Check if this element has a header or title
        if ($element.find('h1, h2, h3, h4, .title, .header').length > 0) score += 5;
        
        // If this is the best candidate so far, save it
        if (score > maxNavScore) {
          maxNavScore = score;
          navElement = $element;
          console.log(`Found navigation element by structure analysis with score: ${score}`);
        }
      });
    }
    
    // If we found a navigation element, extract the tree structure
    if (navElement) {
      // First, try to identify main sections (like "Tracing", "Develop", etc.)
      const mainSections = [];
      const processedTitles = new Set(); // Track processed titles to avoid duplicates
      
      // Universal navigation tree processor that works with various documentation sites
      const processNavItems = () => {
        // Track different levels of navigation
        const topLevelSections = [];
        const mainSections = [];
        
        // Step 1: Analyze the navigation structure to determine its pattern
        const navStructureAnalysis = {
          hasTopLevelItems: false,
          hasMainSections: false,
          hasSubSections: false,
          topLevelSelector: null,
          mainSectionSelector: null,
          subSectionSelector: null
        };
        
        // Try to identify the navigation pattern by looking at the DOM structure
        const detectNavigationPattern = () => {
          // Check for common documentation site patterns
          
          // Pattern 1: Top-level items (e.g., Docs, Guides) -> Sections -> Items
          const topLevelItems = navElement.find('> a, > ul > li > a, > div > a, > div > ul > li > a').filter((_, el) => {
            const text = $(el).text().trim();
            return text.length > 2 && !text.includes('http');
          });
          
          if (topLevelItems.length >= 1) {
            navStructureAnalysis.hasTopLevelItems = true;
            navStructureAnalysis.topLevelSelector = topLevelItems.first().get(0).tagName;
          }
          
          // Pattern 2: Main sections with headers (e.g., Tracing, Introduction)
          const potentialSections = navElement.find('h1, h2, h3, h4, strong, b, [class*="heading"], [class*="header"], [class*="title"]').filter((_, el) => {
            const $el = $(el);
            // Check if this element has links following it or is a parent of links
            return $el.next('a, ul, ol, div').length > 0 || $el.find('a').length > 0 || $el.parent().find('a').length > 0;
          });
          
          if (potentialSections.length >= 1) {
            navStructureAnalysis.hasMainSections = true;
            navStructureAnalysis.mainSectionSelector = potentialSections.first().get(0).tagName;
          }
          
          // Pattern 3: Expandable subsections (items with child items)
          const expandableItems = navElement.find('li:has(ul), div:has(ul), a:has(+ ul), a:has(svg), a:has(img[alt*="expand"])');
          
          if (expandableItems.length >= 1) {
            navStructureAnalysis.hasSubSections = true;
            navStructureAnalysis.subSectionSelector = expandableItems.first().get(0).tagName;
          }
          
          return navStructureAnalysis;
        };
        
        // Analyze the navigation structure
        detectNavigationPattern();
        
        // Step 2: Extract top-level items if they exist
        if (navStructureAnalysis.hasTopLevelItems) {
          // Find top-level navigation items (Docs, Guides, etc.)
          navElement.find('a').each((_, link) => {
            const $link = $(link);
            const linkText = $link.text().trim();
            
            // Skip if empty or already processed
            if (!linkText || processedTitles.has(linkText)) return;
            
            // Check if this looks like a top-level item
            // 1. It's directly under the navigation element or with minimal nesting
            // 2. It has a simple/short name typical of main navigation
            const isDirectChild = $link.parent().parent().is(navElement) || 
                                $link.parent().parent().parent().is(navElement);
            
            const isTopLevelName = /(docs|documentation|guide|tutorial|api|reference|example|concept|overview|start)/i.test(linkText) && 
                                 linkText.length < 30;
            
            if (!isDirectChild && !isTopLevelName) return;
            
            const href = $link.attr('href');
            if (!href) return;
            
            // Handle relative URLs
            let fullUrl;
            try {
              fullUrl = new URL(href, normalizedUrl).href;
            } catch (e) {
              return;
            }
            
            processedTitles.add(linkText);
            const itemId = `top-${linkText.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
            
            topLevelSections.push({
              id: itemId,
              title: linkText,
              url: fullUrl,
              parentId: null,
              children: []
            });
          });
        }
        
        // Step 3: Extract main sections using multiple strategies
        // Strategy 1: Look for elements that are likely section headers within the navigation element only
        // We're specifically targeting elements within the sidebar, not page content
        const sectionHeaderElements = navElement.find('h1, h2, h3, h4, strong, b, [class*="heading"], [class*="header"], [class*="title"], [class*="section"]').filter((_, el) => {
          const $el = $(el);
          // Only include elements that are likely to be navigation headers
          // 1. They should be relatively short (typical for nav headers)
          // 2. They should have links following them or be parents of links
          // 3. They should not be deeply nested in the DOM
          const text = $el.text().trim();
          const hasLinks = $el.next().find('a').length > 0 || $el.parent().find('a').length > 0;
          const nestingLevel = $(el).parents().length;
          return text.length < 50 && hasLinks && nestingLevel < 15;
        });
        
        sectionHeaderElements.each((_, header) => {
          const $header = $(header);
          const sectionTitle = $header.text().trim();
          
          // Skip if empty, too short, or already processed
          if (!sectionTitle || sectionTitle.length < 3 || processedTitles.has(sectionTitle)) return;
          
          // Check if this header has links following it
          const hasFollowingLinks = $header.next().find('a').length > 0 || 
                                  $header.parent().find('a').length > 0;
          
          if (!hasFollowingLinks) return;
          
          processedTitles.add(sectionTitle);
          const sectionId = `section-${sectionTitle.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
          
          const section = {
            id: sectionId,
            title: sectionTitle,
            children: [],
            parentId: null
          };
          
          // Find links that belong to this section
          let currentElement = $header.next();
          let nextHeader = $header.nextAll('h1, h2, h3, h4, strong, b, [class*="heading"], [class*="header"], [class*="title"], [class*="section"]').first();
          
          // Process all elements until the next header
          while (currentElement.length && (!nextHeader.length || !currentElement.is(nextHeader))) {
            currentElement.find('a').each((_, link) => {
              const $link = $(link);
              const linkText = $link.text().trim();
              
              // Skip if empty, already processed, or looks like non-navigation text
              if (!linkText || processedTitles.has(linkText) || linkText === sectionTitle) return;
              
              // Skip links that are likely not navigation items (too long or full URLs)
              if (linkText.length > 60 || linkText.includes('http://') || linkText.includes('https://')) return;
              
              const href = $link.attr('href');
              if (!href) return;
              
              // Handle relative URLs
              let fullUrl;
              try {
                fullUrl = new URL(href, normalizedUrl).href;
              } catch (e) {
                return;
              }
              
              // Check if this is an expandable item
              const hasExpandIndicator = 
                $link.next('svg').length > 0 || 
                $link.find('svg').length > 0 || 
                $link.parent().find('> svg').length > 0 ||
                $link.text().includes('>') ||
                $link.parent().find('ul, ol').length > 0;
              
              processedTitles.add(linkText);
              const itemId = `item-${linkText.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
              
              // Process child items if this is expandable
              const childItems = [];
              if (hasExpandIndicator) {
                // Find the child list
                const childList = $link.next('ul, ol').length > 0 ? 
                                $link.next('ul, ol') : 
                                $link.parent().find('> ul, > ol');
                
                if (childList.length > 0) {
                  childList.find('a').each((_, childLink) => {
                    const $childLink = $(childLink);
                    const childText = $childLink.text().trim();
                    
                    // Skip if empty or already processed
                    if (!childText || processedTitles.has(childText)) return;
                    
                    const childHref = $childLink.attr('href');
                    if (!childHref) return;
                    
                    // Handle relative URLs
                    let childFullUrl;
                    try {
                      childFullUrl = new URL(childHref, normalizedUrl).href;
                    } catch (e) {
                      return;
                    }
                    
                    processedTitles.add(childText);
                    const childId = `child-${childText.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
                    
                    childItems.push({
                      id: childId,
                      title: childText,
                      url: childFullUrl,
                      parentId: itemId,
                      children: []
                    });
                  });
                }
              }
              
              section.children.push({
                id: itemId,
                title: linkText,
                url: fullUrl,
                parentId: sectionId,
                children: childItems,
                hasExpand: hasExpandIndicator
              });
            });
            
            currentElement = currentElement.next();
          }
          
          // Only add sections with children
          if (section.children.length > 0) {
            mainSections.push(section);
          }
        });
        
        // Strategy 2: If no sections found, look for list-based navigation
        if (mainSections.length === 0) {
          navElement.find('ul, ol').each((_, list) => {
            const $list = $(list);
            
            // Skip nested lists - we only want top-level lists
            if ($list.parents('ul, ol').length > 0) return;
            
            // Check if this list has a header
            let sectionTitle = '';
            const prevElement = $list.prev('h1, h2, h3, h4, strong, b, [class*="heading"], [class*="header"], [class*="title"]');
            
            if (prevElement.length > 0) {
              sectionTitle = prevElement.text().trim();
            } else {
              // Try to find a title in the parent element
              const parentTitle = $list.parent().find('> h1, > h2, > h3, > h4, > strong, > b, > [class*="heading"], > [class*="header"], > [class*="title"]').first();
              if (parentTitle.length > 0) {
                sectionTitle = parentTitle.text().trim();
              }
            }
            
            // If no title found, use the first link as a section name
            if (!sectionTitle) {
              const firstLink = $list.find('> li > a').first();
              if (firstLink.length > 0) {
                sectionTitle = firstLink.text().trim();
                // Skip processing this link later
                processedTitles.add(sectionTitle);
              }
            }
            
            // Skip if no title or already processed
            if (!sectionTitle || processedTitles.has(sectionTitle)) return;
            
            processedTitles.add(sectionTitle);
            const sectionId = `section-${sectionTitle.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
            
            const section = {
              id: sectionId,
              title: sectionTitle,
              children: [],
              parentId: null
            };
            
            // Process links in this list
            $list.find('a').each((_, link) => {
              const $link = $(link);
              const linkText = $link.text().trim();
              
              // Skip if empty, already processed, or same as section title
              if (!linkText || processedTitles.has(linkText) || linkText === sectionTitle) return;
              
              const href = $link.attr('href');
              if (!href) return;
              
              // Handle relative URLs
              let fullUrl;
              try {
                fullUrl = new URL(href, normalizedUrl).href;
              } catch (e) {
                return;
              }
              
              // Check if this is an expandable item
              const hasExpandIndicator = 
                $link.next('svg').length > 0 || 
                $link.find('svg').length > 0 || 
                $link.parent().find('> svg').length > 0 ||
                $link.text().includes('>') ||
                $link.parent().find('ul, ol').length > 0;
              
              processedTitles.add(linkText);
              const itemId = `item-${linkText.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
              
              // Process child items if this is expandable
              const childItems = [];
              if (hasExpandIndicator) {
                const childList = $link.parent().find('> ul, > ol');
                if (childList.length > 0) {
                  childList.find('a').each((_, childLink) => {
                    const $childLink = $(childLink);
                    const childText = $childLink.text().trim();
                    
                    // Skip if empty or already processed
                    if (!childText || processedTitles.has(childText)) return;
                    
                    const childHref = $childLink.attr('href');
                    if (!childHref) return;
                    
                    // Handle relative URLs
                    let childFullUrl;
                    try {
                      childFullUrl = new URL(childHref, normalizedUrl).href;
                    } catch (e) {
                      return;
                    }
                    
                    processedTitles.add(childText);
                    const childId = `child-${childText.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
                    
                    childItems.push({
                      id: childId,
                      title: childText,
                      url: childFullUrl,
                      parentId: itemId,
                      children: []
                    });
                  });
                }
              }
              
              section.children.push({
                id: itemId,
                title: linkText,
                url: fullUrl,
                parentId: sectionId,
                children: childItems,
                hasExpand: hasExpandIndicator
              });
            });
            
            // Only add sections with children
            if (section.children.length > 0) {
              mainSections.push(section);
            }
          });
        }
        
        // Step 4: Connect top-level items with main sections if both exist
        if (topLevelSections.length > 0 && mainSections.length > 0) {
          // Try to find a "Docs" or "Documentation" section to attach main sections to
          const docsSection = topLevelSections.find(section => 
            /docs|documentation|guide|manual/i.test(section.title) || 
            (section.url && section.url.includes('/docs'))
          );
          
          if (docsSection) {
            docsSection.children = mainSections;
            mainSections.forEach(section => {
              section.parentId = docsSection.id;
            });
            return topLevelSections;
          }
        }
        
        // Return the most appropriate structure
        return mainSections.length > 0 ? mainSections : topLevelSections;
      };
      
      // Process the navigation and add to our tree
      navigationTree.push(...processNavItems());
    } else {
      // Fallback: First try to find a sidebar-like structure before using headings
      console.log('Looking for sidebar-like structure as fallback');
      
      // Look for elements that have characteristics of a sidebar
      let sidebarCandidate = null;
      let maxSidebarScore = 0;
      
      $('div, nav, aside, ul').each((_, element) => {
        const $element = $(element);
        
        // Skip elements that are likely main content
        if ($element.is('main, article, [role="main"]') || 
            $element.parents('main, article, [role="main"]').length > 0) {
          return;
        }
        
        // Skip very large elements (likely the main content) or tiny elements
        const elementSize = $element.find('*').length;
        if (elementSize < 5 || elementSize > 1000) return;
        
        // Calculate a "sidebar score" based on sidebar-like characteristics
        const linkCount = $element.find('a').length;
        const listItemCount = $element.find('li').length;
        const nestedListCount = $element.find('ul ul, ol ol, ul ol, ol ul').length;
        
        // Skip elements with too few links
        if (linkCount < 5) return;
        
        // Calculate score
        let score = linkCount * 2 + listItemCount + (nestedListCount * 3);
        
        // Check link density - sidebars typically have high link density
        const linkDensity = linkCount / elementSize;
        if (linkDensity > 0.3) score += 15;
        
        // Prefer elements on the left or right side (typical sidebar position)
        const position = $element.css('position');
        if (position === 'fixed' || position === 'sticky' || position === 'absolute') score += 10;
        
        if (score > maxSidebarScore) {
          maxSidebarScore = score;
          sidebarCandidate = $element;
        }
      });
      
      if (sidebarCandidate && maxSidebarScore > 20) {
        console.log('Found sidebar-like structure with score:', maxSidebarScore);
        navElement = sidebarCandidate;
        // Process the navigation element using the existing processNavItems function
        navigationTree.push(...processNavItems());
      } else {
        // If still no good sidebar candidate, only then fall back to headings
        console.log('No sidebar structure found, falling back to headings-based tree');
        
        // Only use headings from the main content area, not the entire page
        const headingTree = [];
        let currentH1 = null;
        let currentH2 = null;
        
        // Limit headings to those in the main content area to avoid including everything
        $('main, article, [role="main"], .content, #content').find('h1, h2, h3').each((_, element) => {
        const text = $(element).text().trim();
        if (!text) return;
        
        const id = `heading-${text.toLowerCase().replace(/[^a-z0-9]/g, '-')}`;
        const tagName = $(element).prop('tagName').toLowerCase();
        
        if (tagName === 'h1') {
          currentH1 = { id, title: text, children: [] };
          currentH2 = null;
          headingTree.push(currentH1);
        } else if (tagName === 'h2' && currentH1) {
          currentH2 = { id, title: text, parentId: currentH1.id, children: [] };
          currentH1.children.push(currentH2);
        } else if (tagName === 'h3' && currentH2) {
          currentH2.children.push({ id, title: text, parentId: currentH2.id, children: [] });
        }
      });
      
      // Only use heading tree as navigation if we couldn't find a proper sidebar
      // This helps prevent including all page headers in the navigation
      if (headingTree.length > 0 && navigationTree.length === 0) {
        navigationTree.push(...headingTree);
      }
    }
    
    // Extract sections with better content targeting - only from main content areas, not navigation
    // First, exclude any elements that are part of the navigation to avoid duplication
    const contentSelectors = 'main, article, .content, .documentation, #content';
    const contentAreas = $(contentSelectors).not(navElement).not(navElement.find('*'));
    
    contentAreas.find('h1, h2, h3').each((index, element) => {
      const title = $(element).text().trim();
      
      // Get content until next heading or end of section
      let contentText = '';
      let node = $(element).next();
      while (node.length && !node.is('h1, h2, h3')) {
        contentText += node.text().trim() + ' ';
        node = node.next();
      }
      
      if (title && contentText.trim()) {
        const sectionId = `${pagePath}-section-${index}`;
        contents.push({
          id: sectionId,
          title,
          content: { 
            type: 'doc', 
            content: [{ 
              type: 'paragraph', 
              content: [{ 
                type: 'text', 
                text: contentText.trim() 
              }] 
            }] 
          },
          url: normalizedUrl + '#' + title.toLowerCase().replace(/\s+/g, '-'),
          parentId: pagePath
        });
        
        // Add this section to the main content's children
        mainContent.children.push(sectionId);
      }
    });
    
    // Only proceed with link extraction if we haven't reached max depth
    if (currentDepth < maxDepth) {
      // Find all links in the navigation that are likely documentation pages
      const navLinks = [];
      
      // Extract links from our navigation tree
      const extractLinksFromTree = (items) => {
        items.forEach(item => {
          if (item.url) navLinks.push(item.url);
          if (item.children && item.children.length > 0) {
            extractLinksFromTree(item.children);
          }
        });
      };
      
      extractLinksFromTree(navigationTree);
      
      // If no nav links found, fall back to all links in the page
      if (navLinks.length === 0) {
        $('a').each((_, element) => {
          const href = $(element).attr('href');
          if (!href) return;
          
          // Skip anchors, external links, and non-documentation links
          if (href.startsWith('#') || href.startsWith('mailto:') || href.startsWith('tel:')) return;
          if (href.match(/\.(jpg|jpeg|png|gif|pdf|zip|exe)$/i)) return;
          
          // Construct absolute URL
          try {
            const absoluteUrl = new URL(href, normalizedUrl).href;
            
            // Only include links from the same domain and documentation section
            const linkUrl = new URL(absoluteUrl);
            if (linkUrl.origin !== baseUrl) return;
            
            // Check if it's a documentation page (customize this based on the site structure)
            if (normalizedUrl.includes('/docs') && !absoluteUrl.includes('/docs')) return;
            
            navLinks.push(absoluteUrl);
          } catch (e) {
            // Invalid URL, skip
            return;
          }
        });
      }
      
      // Process unique links (limit to 10 per page to avoid overwhelming)
      const uniqueLinks = [...new Set(navLinks)].slice(0, 10);
      
      // Recursively scrape linked pages
      for (const link of uniqueLinks) {
        if (!visitedUrls.has(link)) {
          const result = await scrapeWebsite(link, maxDepth, currentDepth + 1, visitedUrls);
          
          // Merge contents and navigation tree from child pages
          contents.push(...result.contents);
          
          // Add child navigation items to our tree if they're not already there
          result.navigationTree.forEach(childNavItem => {
            // Check if this item already exists in our tree
            const exists = navigationTree.some(item => 
              item.title === childNavItem.title && item.url === childNavItem.url
            );
            
            if (!exists) {
              navigationTree.push(childNavItem);
            }
          });
        }
      }
    }
    
    // Filter out items that are likely not part of the actual navigation
    // These are common patterns found in documentation sites but not actual navigation items
    const filteredNavigationTree = navigationTree.filter(item => {
      // Skip items that are likely not navigation items
      const nonNavPatterns = [
        'was this page useful',
        'questions',
        'subscribe',
        'feedback',
        'help',
        'contact',
        'support',
        'step ',
        'interactive',
        'demo'
      ];
      
      // Check if this item or any of its children match non-navigation patterns
      const containsNonNavPattern = (navItem) => {
        const title = navItem.title?.toLowerCase() || '';
        // Check if this item matches any non-navigation pattern
        if (nonNavPatterns.some(pattern => title.includes(pattern))) {
          return true;
        }
        
        // Check children recursively
        if (navItem.children && navItem.children.length > 0) {
          return navItem.children.some(containsNonNavPattern);
        }
        
        return false;
      };
      
      // Keep items that don't match non-navigation patterns
      return !containsNonNavPattern(item);
    });
    
    return { contents, navigationTree: filteredNavigationTree };
  } catch (error) {
    return { contents: [], navigationTree: [] };
  }
};


export { createWorkspace, getTeamWorkspaces, getWorkspaceById, updateContent, addContent, scrapeWebsite };

